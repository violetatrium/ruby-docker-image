#!/usr/bin/env python3

"""
After the sonar-scanner scans a repository, we still don't know what the quality gate status is.
Quality gate processing happens on the sonarqube server, so we need to poll the server until it completes.

If there was no issue with the quality gate, this will exit 0 (pass) anything else is a failure or error.

This file is generated by the sonar-scanner, giving us some way to get details on the scan:
cat .scannerwork/report-task.txt

projectKey=test-scan
serverUrl=https://{SONAR_PROD_HOST}
serverVersion={SERVER_VERSION}}
dashboardUrl=https://{SONAR_PROD_HOST}/dashboard/index/test-scan
ceTaskId=AWtReStgvft-IoQmol_O
ceTaskUrl=https://{SONAR_PROD_HOST}/api/ce/task?id=AWtReStgvft-IoQmol_O


Using 'the ceTaskUrl' above, we can get the quality gate status under 'status':
https://${SONAR_PROD_TOKEN}@{SONAR_PROD_HOST}/api/ce/task?id=AWtReStgvft-IoQmol_O

{
  "task": {
    "id": "AWtReStgvft-IoQmol_O",
    "type": "REPORT",
    "componentId": "AWtReSqXvft-IoQmol_I",
    "componentKey": "test-scan",
    "componentName": "test-scan",
    "componentQualifier": "TRK",
    "analysisId": "AWtReTKcweLrtn5zNhna",
    "status": "SUCCESS",
    "submittedAt": "2019-06-13T15:33:43+0000",
    "submitterLogin": "circleci-pipeline",
    "startedAt": "2019-06-13T15:33:45+0000",
    "executedAt": "2019-06-13T15:33:46+0000",
    "executionTimeMs": 943,
    "logs": false,
    "hasScannerContext": true,
    "organization": "default-organization"
  }
}


"""
import shlex
import subprocess
import argparse
import json
import os
import sys
import time
import logging

logger = logging.getLogger('sonar-waittask')
logger.setLevel(logging.INFO)
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)


def main():
    sleep_time = 6
    max_task_checks = 50

    parser = argparse.ArgumentParser()
    parser.add_argument("scan_report_file")
    parser.add_argument("env_token_name")
    args = parser.parse_args()

    with open(args.scan_report_file, 'r') as fp:
        scan_report_raw_data = fp.readlines()

    scan_report_data = {}
    for line in scan_report_raw_data:
        line = line.strip()
        if not line:
            continue
        key, value = line.split('=', 1)
        scan_report_data[key] = value

    scan_task_url = scan_report_data['ceTaskUrl']
    request_url = scan_task_url.replace('://', '://{}@'.format(os.environ[args.env_token_name]))

    scan_status = None
    scan_task_data = {}

    task_check_count = 0
    while task_check_count < max_task_checks:
        task_check_count += 1
        logger.info("Checking task status: {!r}".format(scan_task_url))

        # there were multiple attempts to use requests lib here, but could not authenticate
        curl_process = subprocess.Popen(shlex.split("curl --connect-timeout 10 {}".format(request_url)),
                                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        stdout, stderr = curl_process.communicate()

        if curl_process.returncode:
            logger.error(stderr)
            sys.exit(1)

        scan_task_data = json.loads(stdout.decode('utf-8'))

        scan_status = scan_task_data['task']['status']
        logger.info("Scan status: {!r}".format(scan_status))

        if scan_status in ['SUCCESS', 'FAILED']:
            break
        else:
            time.sleep(sleep_time)

    pretty_data = json.dumps(scan_task_data, indent=2)
    print(pretty_data)

    if scan_status != 'SUCCESS' and (scan_status == 'FAILED' or task_check_count == max_task_checks):
        sys.exit(1)


if __name__ == '__main__':
    main()
